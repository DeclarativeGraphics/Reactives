THOUGHTS:

  Abstractions are cases and lambdas in one.
For normal haskell-like case: sumvalue |> lambda ... -> -> -> ->
IMO, in elm it happens too often, that records get a name as a whole
and then the name is only used once in a case expr, unlike in haskell,
where you can already do a case on the left of a = of a func.
In haskell there is now 2 ways of doing the same thing though, and I
don't like that.

  There is no variable indexing by STRINGS anymore! Either it's
de-brujin indices or its a global index (I'm all the way for
de-brujin...)
De-brujin would allow the environment to simply be a [IndexAssociation],
and de-brujin index 0 would be the head of the list. Inserting into the
environment would be super easy as well (as it would be needed when
entering a lambda).
Oh and the list tails are shared! Oh man this is too awesome to not do it.
On the flip side the problem with de-brujin indices is that the binding
via the environment is strange to implement. Usually the top-level
environment is not ordered, but for de-brujin indices it must be.

  Selecting an Expression should be possible. There should be options
for wrapping the selected expression in a lambda, applying a function
to it or beta-reducing a lambda.
For example:
5 : Int -- select, click 'wrap lambda'
(\x : a -> 5 : Int) (<hole> : a) -- beta-reduce (option only available
if possible)
5 : Int -- select, click 'apply a function'
(<hole> : Int -> Int) (5 : Int) : Int
These operations are supposed to always keep the type. For thoughts
on this see "Immutable code".
Selecting an expression should also show it's type. (otherwise type is
visible for the body of a lambda (you can read the argument's type from
the record directly))
Deleting an Expression should replace it with a hole of the previous
expression's type. You can delete a hole if it's inside an application
and has type a -> a or any instantiation of that type. For example:
((+1) : Int -> Int) (5 : Int) -- delete (+1)
(<hole> : Int -> Int) (5 : Int) -- delete <hole>
5 : Int

  Immutable code
At least Immutable Types. If a function changes it's type it needs to
be copied to a new function with another type. The idea is to disallow
changes in types in libraries, so you can always use the newest library
version (in dependencies) and it's garunteed to compile!
But yes, on the flip side it means you have to copy EVERY function that
uses your datatype once you change it.
That's bad for developing rapidly, but I think there can be a
"development-mode", kinda like a playground, where it's possible to
throw away unused functions quickly and edit datatypes.
All in all this feature needs some thinking, but I'm optimistic it'll
work!
(ALSO: THINK OF WHAT THAT MEANS FOR DEPENDENCY MANAGEMENT!!! NO MORE
DEPENDENCY HELL! AT ALL! SINCE DEPENDENCIES ARE ONLY LOWER-BOUND!)

The above paragraph cleared up a lot when I read unison's editing post
http://unisonweb.org/2016-09-17/editing.html.
